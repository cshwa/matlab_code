function varargout = get_hycom(varargin)
% Gets xxx data.
%
%  Usage:
%
%  get_xxx  
%
%  without arguments brings up GUI that allows a user to select variables, 
%  time, latitude, longitude, layer limits and save data to workspace or files. 
%  All selections are saved in a cell array Request.
%
%  get_xxx(Request)
%
%  gets data selected by a prior call which was saved in the cell array Request.
%
%  Files: get_xxx.m      - main function, this file
%         dsi_xxx.m      - describes/generates dataset inventory and interface
%         dsi_xxx.mat    - contains dataset inventory
%         gui_xxx.m      - GUI function
%         gui_xxx.fig    - GUI graphic window
%         gui_xxx_request.mat    - contains the last Request
%  
% OPeNDAP Science Team
% Copyright 2007-2009
% $Version 3.1.2$

%==========================================================================
% Meri Sheremet
%
% REVISION HISTORY:
% 2007/01/01 created, ms
% 2008/03/13 introduced DSI; 
% 2008/12 all toolbox rewritten to be uniform in structure, vs
%==========================================================================

DSName='HYCOM';
dsname=lower(DSName); %lower case

if ~exist('loaddap')
errordlg('loaddap not found. Make sure it is in your MATLAB path.'); return
end               

dsi_filename = ['dsi_' dsname '.mat'];
%if (~isdeployed)
    pname = mfilename('fullpath');
    pname = pname(1:length(pname) - length(mfilename));
    dsi_filename = [pname,dsi_filename];
%end
dsi_flag = 0;
if exist(dsi_filename,'file')    
%     Get date of file.
    dum = dir(dsi_filename);    
    if floor(now)>datenum(dum.date) %if today's date is different than that of file
        dsi_flag = 1;        
    end    
else %does not exist
    dsi_flag = 1;    
end
if dsi_flag==1    
%h=msgbox(['Acquiring metadata from ' DSName ' site, please wait ...']);
h=msgbox(['Acquiring ' DSName ' metadata, please wait ...']);
% next line makes OK button invisible
hh=get(h,'Children'); set(hh(2),'Visible','off'); pause(1);
dsi_hycom; % dsi_xxx
close(h)
end


if nargin<1
% no arguments passed, get parameters from GUI

h = gui_hycom;
    if nargout>0
        varargout{1} = h; %handle is output.
    end
elseif nargin > 1
disp('Incorrect number of arguments.'); return  
else
% one argument Request, get xxx data  

request=varargin{1}; 
%assignin('base','request',request);
request.RequestDate=datestr(now,'yyyy-mm-dd HH:MM:SS');
R=request;

a=version;a=a(1:3);a=str2num(a);
% for earlier than MATLAB 2008b (Ver 7.7) use third party mexnc package
if strcmp(R.SaveMode,'netcdf') & ~exist('mexnc') & (a < 7.7)
errordlg('mexnc not found. Make sure it is in your MATLAB path.'); return
end   

%R=SetR(R);
R.iTimeIncr=R.DATEINCR;
% load dsi_xxx.mat DSI_xxx_04km_8day
eval(['load dsi_' dsname '.mat DSI_' R.DataSetBranch ';'])
eval(['DSI=DSI_' R.DataSetBranch ';'])
eval(['clear DSI_' R.DataSetBranch ';'])
R.Variables={R.Fields{:},R.Coordinates{:}};
%assignin('base','DSI',DSI);

status=op_checkrequest(DSI,R);           if status>0 return; end
D0=op_initd0(DSI,R); % initialize standard opendap structure;
[R,D0,status]=Coord2Ind(DSI,R,D0);     if status>0 return; end
status=op_chkamntreqdata(DSI,R); if status>0 return; end
% find the latest saved opendap or netcdf frame number
[kw0,kf0]=op_lastframenum(R);
kf=0;

hwaitbar=waitbar(0,'Acquiring ','Name',[DSName ' Download Progress']);
% browse through time
NT=length(R.iTime1:R.iTimeIncr:R.iTime2);
NV=length(R.Fields);
for kT=R.iTime1:R.iTimeIncr:R.iTime2
kf=kf+1; % count time frames for naming opendap_nnnn and files    
DATE=datestr(DSI.Time(kT),'yyyy-mm-dd HH:MM:SS'); 
% processing each time frame and constructing data structure D
D=D0;
    
%D.time=DSI.Time(kT); % datenum;  
D.time=(DSI.Time(kT)-datenum(1970,1,1,0,0,0))*86400;% in seconds since 1970-01-01 00:00:00
D.Attributes.time.units='seconds since 1970-01-01 00:00:00';
D.user_friendly_time=datestr(DSI.Time(kT),'yyyy-mm-dd HH:MM:SS');

    %browse through checked Fields
    for kV=1:NV
FIELD=R.Fields{kV};        
xprogress=((kV-1)/NV+(kf-1))/NT; % progress fraction
%waitbar(xprogress, hwaitbar, ['Acquiring ' strrep(FIELD,'_',' ') ' ' DATE],'Name',[DSName ' Download Progress']);
waitbar(xprogress, hwaitbar, ['Acquiring ' ' ' DATE ' ' strrep(FIELD,'_',' ')],'Name',[DSName ' Download Progress']);
% a general request employed by get_DataSet program has the following pattern
% loaddap([URLSITE URLPATH URLFILE '?' URLCVAR URLCTIME URLCDEPTH URLCLAT URLCLON ])
%   constraints URLCTIME URLCDEPTH URLCLAT URLCLON  can be in different order
%   constraints URLCLAT URLCLON URLCDEPTH will be generated by program get

URLSITE=DSI.URLSITE;
URLPATH=DSI.URLPATH;
URLFILE=DSI.URLFILE;
        if ~isempty(URLFILE)
URLCVAR=eval(['DSI.URLCVAR.' FIELD ';']);

CTIME=['[' num2str(kT-1) ':1:' num2str(kT-1) ']']; % Constraint Time

Coords=eval(['DSI.Variables.' FIELD]);
if  length(Coords)== 3
URL=[URLSITE URLPATH URLFILE '?' URLCVAR CTIME R.CLEVEL R.CLAT R.CLON]; % 3D variables
elseif length(Coords)== 2
URL=[URLSITE URLPATH URLFILE '?' URLCVAR CTIME R.CLAT R.CLON]; % 2D variables
end       

disp(URL)
loaddap(['+v','-e'],URL);
%dods_err = 0 means no error.
%dods_err = 1 means error.
%dods_err_msg [variable where error message is stored]
            if dods_err
                Vars=eval(['D.Variables.' FIELD]);
                nd=[];
                for j=1:length(Vars)
                    nd(j)=length(eval(['D.' Vars{j}]));
                end
                FNAN=NaN(nd);    
        disp(dods_err_msg)
        disp(['Missing or corrupt file or site is not accessible. ' FIELD ' is set to NaN.'])
        eval(['D.' FIELD '=FNAN;']);
            else
A=loaddap(['+v','-A'],URL);

% Rename and change dimensions order
%DSI.FormulaRen.sst=      'f=squeeze(l3m_data);';
FREN=eval(['DSI.FormulaRen.' FIELD]);eval(FREN);
% Replace missing values with NaN
%DSI.FormulaNaN.sst='f(find(f==65535))=NaN;';
FNAN=DSI.FormulaNaN;eval(FNAN);

% Convert to physical units
%DSI.FormulaCnv.sst ='f=A.Global_Attributes.HDF_GLOBAL.Slope*f + A.Global_Attributes.HDF_GLOBAL.Intercept;';
%FCNV=eval(['DSI.FormulaCnv.' FIELD]);eval(FCNV);

eval(['D.' FIELD '=f;']);
eval(['D.Attributes.' FIELD '.url=URL;']);
eval(['D.Attributes.' FIELD '.OriginalAttributes=A;']);
            end
        else
        disp(['Missing file. ' FIELD ' is set to NaN.'])
        eval(['D.' FIELD '=NaN;']);        
        end
    end %kV
status=op_saved(D,R,kf,kf0,kw0);     
end %kT

waitbar(1,hwaitbar,'Acquiring ','Name',[DSName ' Download Progress']);
close(hwaitbar)
%msgbox('The data have been acquired.')
disp('The data have been acquired.')

end % nargin

function [R,D,status]=Coord2Ind(DSI,R,D)
status=0;
if ~strcmp(DSI.DataSetBranch,'HYCOM_Atlantic_Ocean_Prediction_System') & R.LAT2 > 47
    LLATLON2D='y';
    
    if ~exist('Grid.mat','file')    
h=msgbox(['North of 47N HYCOM grid has a nonrectangular polar patch. Latitude and Longitude will be 2D arrays. ' ...
 'First time loading full Latitude and Longitude 2D arrays (64MB) from HYCOM website. Please wait.']);
% next line makes OK button invisible
hh=get(h,'Children'); set(hh(2),'Visible','off'); pause(3);

%URL='http://hycom.coaps.fsu.edu/thredds/dodsC/glb_analysis';
URL=[DSI.URLSITE DSI.URLPATH DSI.URLFILE];
loaddap(['+v','-e'],[URL '?Latitude,Longitude'])
%dods_err = 0 means no error.
%dods_err = 1 means error.
%dods_err_msg [variable where error message is stored]
if dods_err
    disp(dods_err_msg)
    msgbox('Could not access dataset site. Sorry, try again later.');
    status=1;return
end
Latitude=Latitude.Latitude;
Longitude=Longitude.Longitude;
save Grid.mat Latitude Longitude
close(h)
    end

h=msgbox(['North of 47N HYCOM grid has a nonrectangular polar patch. Latitude and Longitude will be 2D arrays. ' ...
 'Loading full Latitude and Longitude 2D arrays from a local file. Please wait.']);
% next line makes OK button invisible
hh=get(h,'Children'); set(hh(2),'Visible','off'); pause(3);
load Grid.mat
%assignin('base','Latitude',Latitude);
%assignin('base','Longitude',Longitude);
close(h)

% fix values at discontinuities
Longitude(end,1:1125)=Longitude(1,1);
Longitude(end,1125+1:1125*3)=Longitude(1,1125*2+1);
Longitude(end,1125*3+1:1125*4)=Longitude(1,1125*4);

% adjust entered longitudes modulo 360 to match the dataset range 
LonM=0.5*(Longitude(1,1)+Longitude(1,end));
R.LON1=R.LON1+floor((LonM+180-R.LON1)/360)*360;
R.LON2=R.LON2+floor((LonM+180-R.LON2)/360)*360;

% find nonrectangular region that completely covers the selected rectangle
%disp('start searching')
%tic
[j11,i11]=gridval2ind2D(Latitude,Longitude,R.LAT1,R.LON1);
[j21,i21]=gridval2ind2D(Latitude,Longitude,R.LAT2,R.LON1);
[j12,i12]=gridval2ind2D(Latitude,Longitude,R.LAT1,R.LON2);
[j22,i22]=gridval2ind2D(Latitude,Longitude,R.LAT2,R.LON2);
%toc
%disp('searching complete')
j1=min([j11,j21,j12,j22]);
j2=max([j11,j21,j12,j22]);
i1=min([i11,i21,i12,i22]);
i2=max([i11,i21,i12,i22]);
% if spanning bipolar pole => latitude increases to maximum 
if ((i1<=1)&(i2>=1)) | ((i1<=1125*2)&(i2>=1125*2+1)) | ((i1<=1125*4)&(i2>=1125*4)) 
    j2=3298;
end
% if spanning bipolar equator => latitude decreases to minimum 
if ((i1<=1125)&(i2>=1125+1)) | ((i1<=1125*3)&(i2>=1125*3+1)) 
[j1125,i1125]=gridval2ind2D(Latitude,Longitude,R.LAT1,Longitude(1,1125));
j1=min([j11,j21,j12,j22,j1125]);
end


R.iLON1=i1;R.iLON2=i2;R.iLAT1=j1;R.iLAT2=j2;

if 1
% plot curvilinear grid
% and opendap rectangular area selection
incr=75;
figure(1); plot(Longitude(1:incr:end,1:incr:end),Latitude(1:incr:end,1:incr:end),'k.'); hold on
plot([R.LON1 R.LON2 R.LON2 R.LON1 R.LON1],[R.LAT1 R.LAT1 R.LAT2 R.LAT2 R.LAT1],'ro-')
plot(Longitude(j11,i11),Latitude(j11,i11),'b*')
plot(Longitude(j21,i21),Latitude(j21,i21),'b*')
plot(Longitude(j12,i12),Latitude(j12,i12),'b*')
plot(Longitude(j22,i22),Latitude(j22,i22),'b*')
plot(Longitude(j1:j2,i1),Latitude(j1:j2,i1),'b-')
plot(Longitude(j1:j2,i2),Latitude(j1:j2,i2),'b-')
plot(Longitude(j1,i1:i2),Latitude(j1,i1:i2),'b-')
plot(Longitude(j2,i1:i2),Latitude(j2,i1:i2),'b-')
axis([70 440 -90 90])
title('HYCOM grid with bipolar patch')
xlabel('Longitude')
ylabel('Latitude')
end

D.Dimensions.Y=length(R.iLAT1:R.LATINCR:R.iLAT2);
D.Dimensions.X=length(R.iLON1:R.LONINCR:R.iLON2);
D.latitude=Latitude(R.iLAT1:R.LATINCR:R.iLAT2,R.iLON1:R.LONINCR:R.iLON2);
D.Variables.latitude={'Y','X'};
D.longitude=Longitude(R.iLAT1:R.LATINCR:R.iLAT2,R.iLON1:R.LONINCR:R.iLON2);
D.Variables.longitude={'Y','X'};

else % standard rectangular grid
Latitude=squeeze(DSI.Latitude);
Longitude=squeeze(DSI.Longitude);

LLATLON2D='n';
% adjust entered longitudes modulo 360 to match the dataset range 
LonM=0.5*(Longitude(1)+Longitude(end));
R.LON1=R.LON1+floor((LonM+180-R.LON1)/360)*360;
R.LON2=R.LON2+floor((LonM+180-R.LON2)/360)*360;
% find indices within the specified range of lons, lats
R.iLON1=min(find(Longitude >= R.LON1));
R.iLON2=max(find(Longitude <= R.LON2));
R.iLAT1=min(find(Latitude >= R.LAT1));
R.iLAT2=max(find(Latitude <= R.LAT2));

D.Dimensions.Y=length(R.iLAT1:R.LATINCR:R.iLAT2);
D.Dimensions.X=length(R.iLON1:R.LONINCR:R.iLON2);
D.latitude=Latitude(R.iLAT1:R.LATINCR:R.iLAT2);
D.Variables.latitude={'Y'};
D.longitude=Longitude(R.iLON1:R.LONINCR:R.iLON2);
D.Variables.longitude={'X'};
end

if ~isempty(strmatch('depth',R.Coordinates))
R.iLEVEL1=min(find(DSI.Depth >= R.DEPTH1));
R.iLEVEL2=max(find(DSI.Depth <= R.DEPTH2));
else 
R.iLEVEL1=1;
R.iLEVEL2=1;
R.LEVELINCR=1;
end
if ~isempty(strmatch('depth',R.Coordinates))
D.depth=DSI.Depth(R.iLEVEL1:R.LEVELINCR:R.iLEVEL2);
D.Dimensions.depth=length(D.depth);
end

R.CLAT=['[' num2str(R.iLAT1-1) ':' num2str(R.LATINCR) ':' num2str(R.iLAT2-1) ']']; % Constraint Latitude
R.CLON=['[' num2str(R.iLON1-1) ':' num2str(R.LONINCR) ':' num2str(R.iLON2-1) ']']; % Constraint Longitude
R.CLEVEL=['[' num2str(R.iLEVEL1-1) ':' num2str(R.LEVELINCR) ':' num2str(R.iLEVEL2-1) ']']; % Constraint Level

JD1=datenum(R.DATE1,'yyyymmdd');
JD2=datenum(R.DATE2,'yyyymmdd')+1;
%assignin('base','Time',Time)
R.iTime1=min(find(DSI.Time >= JD1));
R.iTime2=max(find(DSI.Time <  JD2));

%=======================================================
function [j,i]=gridval2ind2D(Latitude,Longitude,LAT,LON);
[NJ,NI]=size(Latitude);
% using a multigrid method for finding indices
%step 1
jincr=round(sqrt(NJ));
iincr=round(sqrt(NI));
jj=(1:jincr:NJ);
ii=(1:iincr:NI);
a=abs(Latitude(jj,ii)-LAT)+abs(Longitude(jj,ii)-LON); 
[ak k]=min(a(:)); 
[jk,ik]=ind2sub(size(a),k);
jjk=jj(jk);
iik=ii(ik);
% step 2
jj=max(1,jjk-jincr):1:min(NJ,jjk+jincr);
ii=max(1,iik-iincr):1:min(NI,iik+iincr);
a=abs(Latitude(jj,ii)-LAT)+abs(Longitude(jj,ii)-LON); 
[ak k]=min(a(:)); 
[jk,ik]=ind2sub(size(a),k);
jjk=jj(jk);
iik=ii(ik);
j=jjk;
i=iik;

